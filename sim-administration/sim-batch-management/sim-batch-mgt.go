//usr/bin/env go run "$0" "$@"; exit "$?"
package main

import (
	"fmt"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/es2plus"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/outfileconversion"
)

///
///   Main.  The rest should be put into a library.
///

var (
	// TODO: Enable, but also make it have an effect.
	// debug    = kingpin.Flag("debug", "enable debug mode").Default("false").Bool()

	//
	// Smoketest of the ES2Plus interface
	//
	smoketest             = kingpin.Command("es2plus-smoketest", "Smoketest the ES2+ protocol.")
	smoketestCertFilePath = smoketest.Flag("cert", "Certificate pem file.").Required().String()
	smoketestKeyFilePath  = smoketest.Flag("key", "Certificate key file.").Required().String()
	smoketestHostport     = smoketest.Flag("hostport", "host:port of ES2+ endpoint.").Required().String()
	smoketestRequesterId  = smoketest.Flag("requesterid", "ES2+ requester ID.").Required().String()
	smoketestIccidInput   = smoketest.Flag("iccid", "Iccid of profile to manipulate").Required().String()

	//
	// Convert an output (.out) file from an sim profile producer into an input file
	// for Prime.
	//

	/**
	 * OLD COMMENTS: Not yet reworked into doc for this script, but mostly accurate
	 *  nonetheless.
	 *
	 * This program is intended to be used from the command line, and will convert an
	 * output file from a sim card vendor into an input file for a HSS. The assumptions
	 * necessary for this to work are:
	 *
	 *  * The SIM card vendor produces output files similar to the example .out file
	 *     found in the same source directory as this program
	 *
	 *  * The HSS accepts input as a CSV file, with header line 'ICCID, IMSI, KI' and subsequent
	 *    lines containing ICCID/IMSI/Ki fields, all separated by commas.
	 *
	 * Needless to say, the outmost care should be taken when handling Ki values and
	 * this program must, as a matter of course, be considered a security risk, as
	 * must all  software that touch SIM values.
	 *
	 * With that caveat in place, the usage of this program typically looks like
	 * this:
	 *
	 *    ./outfile_to_hss_input_converter.go  \
	 *              -input-file sample_out_file_for_testing.out
	 *              -output-file-prefix  ./hss-input-for-
	 *
	 * (followed by cryptographically strong erasure of the .out file,
	 *  encapsulation of the .csv file in strong cryptography etc., none
	 *  of which are handled by this script).
	 */

	spUpload          = kingpin.Command("sim-profile-upload", "Convert an output (.out) file from an sim profile producer into an input file for an HSS.")
	spUploadInputFile = smoketest.Flag("input-file", "path to .out file used as input file").Required().String()
	spUploadOutputFiePrefix = smoketest.Flag("output-file-prefix",
		"prefix to path to .csv file used as input file, filename will be autogenerated").Required().String()

	// TODO: Check if this can be used for the key files.
	// postImage   = post.Flag("image", "image to post").ExistingFile()
)

func main() {
	switch kingpin.Parse() {
	case "es2plusSmoketest":
		es2PlusSmoketest(smoketestCertFilePath, smoketestKeyFilePath, smoketestHostport, smoketestRequesterId, smoketestIccidInput)
	case "simProfilerUpload":
		outfileconversion.ConvertInputfileToOutputfile(*inputFile, *outputFilePrefix)
	default:
		panic("Unknown command.")
	}
}

// TODO:  Replace this with a set of commands that are directly useful as
//        an alternative to the web interface (update, prepare, query, etc.)
func es2PlusSmoketest(certFilePath *string, keyFilePath *string, hostport *string, requesterId *string, iccidInput *string) {

	fmt.Printf("certFilePath = '%s'\n", *certFilePath)
	fmt.Printf("keyFilePath  = '%s'\n", *keyFilePath)
	fmt.Printf("hostport     = '%s'\n", *hostport)
	fmt.Printf("requesterId  = '%s'\n", *requesterId)
	fmt.Printf("iccidInput   = '%s'\n", *iccidInput)

	iccid := *iccidInput

	client := es2plus.Client(*certFilePath, *keyFilePath, *hostport, *requesterId)

	result, err := es2plus.GetStatus(client, iccid)
	if err != nil {
		panic(err)
	}
	fmt.Println("result1 -> ", result.State)

	result2, err := es2plus.RecoverProfile(client, iccid, "AVAILABLE")
	if err != nil {
		panic(err)
	}

	fmt.Println("result2 -> ", result2)

	result, err = es2plus.GetStatus(client, iccid)
	if err != nil {
		panic(err)
	}

	fmt.Println("result3 -> ", result.State)

	result4, err := es2plus.RecoverProfile(client, iccid, "AVAILABLE")
	if err != nil {
		panic(err)
	}

	fmt.Println("result4 -> ", result4)

	result, err = es2plus.GetStatus(client, iccid)
	if err != nil {
		panic(err)
	}

	fmt.Println("result5 -> ", result.State)

	if result.State != "AVAILABLE" {
		panic("Couldn't convert state of iccid into AVAILABLE")
	}

	result6, err := es2plus.DownloadOrder(client, iccid)
	fmt.Println("result6 -> ", result6)
	if err != nil {
		panic(err)
	}

	result7, err := es2plus.GetStatus(client, iccid)
	if err != nil {
		panic(err)
	}
	fmt.Println("result7 -> ", result7)

	result8, err := es2plus.ConfirmOrder(client, iccid)
	fmt.Println("result8 -> ", result8)
	if err != nil {
		panic(err)
	}

	result9, err := es2plus.GetStatus(client, iccid)
	if err != nil {
		panic(err)
	}
	fmt.Println("result9 -> ", result9)

	if result.State != "RELEASED" {
		panic("Couldn't convert state of sim profile into RELEASED")
	}

	fmt.Println("Success")
}
