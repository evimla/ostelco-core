package org.ostelco.prime.storage.scaninfo

import arrow.core.Either
import arrow.core.fix
import arrow.effects.IO
import arrow.instances.either.monad.monad
import arrow.typeclasses.binding
import com.codahale.metrics.health.HealthCheck
import com.fasterxml.jackson.databind.ObjectMapper
import com.google.cloud.NoCredentials
import com.google.cloud.datastore.*
import com.google.cloud.datastore.testing.LocalDatastoreHelper
import com.google.cloud.http.HttpTransportOptions
import io.dropwizard.setup.Environment
import org.ostelco.prime.getLogger
import org.ostelco.prime.model.*
import org.ostelco.prime.storage.*
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URL
import java.util.*
import javax.ws.rs.core.MultivaluedMap


class ScanInfoStore : ScanInformationStore by ScanInformationStoreSingleton

/**
 * Helper class for getting environment variables.
 * Introduced to help testing.
 */
open class EnvironmentVars {
    /**
     * Retrieve the value of the environbment variable.
     */
    open fun getVar(name: String): String? = System.getenv(name)
}

object ScanInformationStoreSingleton : ScanInformationStore {

    private val logger by getLogger()
    private lateinit var datastore: Datastore
    // Used by unit tests
    private lateinit var localDatastoreHelper: LocalDatastoreHelper

    /* Generated by Jumio and can be obtained from the console. */
    private lateinit var apiToken: String
    private lateinit var apiSecret: String

    override fun upsertVendorScanInformation(subscriberId: String, vendorData: MultivaluedMap<String, String>): Either<StoreError, Unit> {
        try {
            return IO {
                Either.monad<StoreError>().binding {
                    val key = datastore.newKeyFactory().setKind(VendorScanData.TYPE_NAME.s).newKey(subscriberId)

                    val entityBuilder = Entity.newBuilder(key)
                    val vendorScanInformation = createVendorScanInformation(vendorData).bind()
                    entityBuilder.set(VendorScanData.ID.s, vendorScanInformation.scanId)
                    entityBuilder.set(VendorScanData.DETAILS.s, vendorScanInformation.scanDetails)
                    if (vendorScanInformation.scanImage != null) {
                        entityBuilder.set(VendorScanData.IMAGE.s, BlobValue.newBuilder(vendorScanInformation.scanImage).setExcludeFromIndexes(true).build())
                    }
                    if (vendorScanInformation.scanImageType != null) {
                        entityBuilder.set(VendorScanData.IMAGE_TYPE.s, vendorScanInformation.scanImageType)
                    }
                    if (vendorScanInformation.scanImageBackside != null) {
                        entityBuilder.set(VendorScanData.IMAGEBACKSIDE.s, BlobValue.newBuilder(vendorScanInformation.scanImageBackside).setExcludeFromIndexes(true).build())
                    }
                    if (vendorScanInformation.scanImageBacksideType != null) {
                        entityBuilder.set(VendorScanData.IMAGEBACKSIDE_TYPE.s, vendorScanInformation.scanImageBacksideType)
                    }
                    if (vendorScanInformation.scanImageFace != null) {
                        entityBuilder.set(VendorScanData.IMAGEFACE.s, BlobValue.newBuilder(vendorScanInformation.scanImageFace).setExcludeFromIndexes(true).build())
                    }
                    if (vendorScanInformation.scanImageFaceType != null) {
                        entityBuilder.set(VendorScanData.IMAGEFACE_TYPE.s, vendorScanInformation.scanImageFaceType)
                    }
                    datastore.put(entityBuilder.build())
                    Unit
                }.fix()
            }.unsafeRunSync()
        } catch (e: DatastoreException) {
            return Either.left(NotCreatedError(VendorScanData.TYPE_NAME.s, subscriberId))
        }
    }

    fun createVendorScanInformation(vendorData: MultivaluedMap<String, String>): Either<StoreError, VendorScanInformation> {
        return JumioHelper.generateVendorScanInformation(vendorData, apiToken, apiSecret)
    }

    fun __getVendorScanInformation(subscriberId: String): Either<StoreError, VendorScanInformation> {
        try {
            val key = datastore.newKeyFactory().setKind(VendorScanData.TYPE_NAME.s).newKey(subscriberId)
            val entity = datastore.get(key)
            val scanImage :Blob? = if (entity.contains(VendorScanData.IMAGE.s)) entity.getBlob(VendorScanData.IMAGE.s) else null
            val scanImageBackside :Blob? = if (entity.contains(VendorScanData.IMAGEBACKSIDE.s)) entity.getBlob(VendorScanData.IMAGEBACKSIDE.s) else null
            val scanImageFace :Blob? = if (entity.contains(VendorScanData.IMAGEFACE.s)) entity.getBlob(VendorScanData.IMAGEFACE.s) else null
            return Either.right(VendorScanInformation(
                    entity.getString(VendorScanData.ID.s),
                    entity.getString(VendorScanData.DETAILS.s),
                    scanImage,
                    if (entity.contains(VendorScanData.IMAGE_TYPE.s)) entity.getString(VendorScanData.IMAGE_TYPE.s) else null,
                    scanImageBackside,
                    if (entity.contains(VendorScanData.IMAGEBACKSIDE_TYPE.s)) entity.getString(VendorScanData.IMAGEBACKSIDE_TYPE.s) else null,
                    scanImageFace,
                    if (entity.contains(VendorScanData.IMAGEFACE_TYPE.s)) entity.getString(VendorScanData.IMAGEFACE_TYPE.s) else null
            ))
        }
        catch (e: DatastoreException) {
            return Either.left(NotFoundError(VendorScanData.TYPE_NAME.s, subscriberId))
        }
    }

    fun init(env: Environment?, environmentVars:EnvironmentVars) {
        if (ConfigRegistry.config.datastoreType != "inmemory-emulator") {
            // Don't throw error during local tests
            apiToken = environmentVars.getVar("JUMIO_API_TOKEN")
                    ?: throw Error("Missing environment variable JUMIO_API_TOKEN")
            apiSecret = environmentVars.getVar("JUMIO_API_SECRET")
                    ?: throw Error("Missing environment variable JUMIO_API_SECRET")
        } else {
            apiToken = ""
            apiSecret = ""
        }
        initDatastore(env)
    }

    fun cleanup() {
        if (ConfigRegistry.config.datastoreType == "inmemory-emulator") {
            // Stop the emulator after unit tests.
            logger.info("Stopping in-memory datastore emulator")
            localDatastoreHelper.stop()
        }
    }

    // Integration testing helper for Datastore.
    private fun initDatastore(env: Environment?) {
        datastore = when (ConfigRegistry.config.datastoreType) {
            "inmemory-emulator" -> {
                logger.info("Starting with in-memory datastore emulator")
                localDatastoreHelper = LocalDatastoreHelper.create(1.0)
                localDatastoreHelper.start()
                localDatastoreHelper.options
            }
            "emulator" -> {
                // When prime running in GCP by hosted CI/CD, Datastore client library assumes it is running in
                // production and ignore our instruction to connect to the datastore emulator. So, we are explicitly
                // connecting to emulator
                logger.info("Connecting to datastore emulator")
                DatastoreOptions
                        .newBuilder()
                        .setHost("localhost:9090")
                        .setCredentials(NoCredentials.getInstance())
                        .setTransportOptions(HttpTransportOptions.newBuilder().build())
                        .build()
            }
            else -> {
                logger.info("Created default instance of datastore client")
                DatastoreOptions
                        .newBuilder()
                        .setNamespace(ConfigRegistry.config.namespace)
                        .build()
            }
        }.service

        // health-check for datastore
        env?.healthChecks()?.register("datastore", object : HealthCheck() {
            override fun check(): Result {
                try {
                    val testKey = datastore.newKeyFactory().setKind("TestKind").newKey("testKey")
                    val testPropertyKey = "testPropertyKey"
                    val testPropertyValue = "testPropertyValue"
                    val testEntity = Entity.newBuilder(testKey).set(testPropertyKey, testPropertyValue).build()
                    datastore.put(testEntity)
                    val value = datastore.get(testKey).getString(testPropertyKey)
                    datastore.delete(testKey)
                    if (testPropertyValue != value) {
                        logger.warn("Unable to fetch test property value from datastore")
                        return Result.builder().unhealthy().build()
                    }
                    return Result.builder().healthy().build()
                } catch (e: Exception) {
                    return Result.builder().unhealthy(e).build()
                }
            }
        })
    }
}

/**
 * A utility for downloading and creating the scan information for Jumio clients.
*/
object JumioHelper {
    /**
     * Retrieves the contents of a file from a URL
     */
    fun downloadFileAsBlob(fileURL: String, username: String, password: String): Either<StoreError, Pair<Blob, String>> {
        val url = URL(fileURL)
        val httpConn = url.openConnection() as HttpURLConnection
        val userpass = "$username:$password"
        val authHeader = "Basic ${Base64.getEncoder().encodeToString(userpass.toByteArray())}"
        httpConn.setRequestProperty("Authorization", authHeader)

        try {
            val responseCode = httpConn.responseCode
            // always check HTTP response code first
            if (responseCode != HttpURLConnection.HTTP_OK) {
                val statusMessage = "$responseCode: ${httpConn.responseMessage}"
                return Either.left(FileDownloadError(fileURL, statusMessage));
            }
            val contentType = httpConn.contentType
            val inputStream = httpConn.inputStream
            val fileData = Blob.copyFrom(inputStream)
            inputStream.close()
            return Either.right(Pair(fileData, contentType))
        }
        catch (e: IOException) {
            val statusMessage = "IOException: $e"
            return Either.left(FileDownloadError(fileURL, statusMessage))
        } finally {
            httpConn.disconnect()
        }
    }

    fun generateVendorScanInformation(vendorData: MultivaluedMap<String, String>, apiToken: String, apiSecret: String): Either<StoreError, VendorScanInformation> {
        var scanImage:Blob? = null
        var scanImageType: String? = null
        var scanImageBackside: Blob? = null
        var scanImageBacksideType: String? = null
        var scanImageFace: Blob? = null
        var scanImageFaceType: String? = null

        val scanId: String = vendorData.getFirst(JumioScanData.SCAN_ID.s)
        val scanDetails: String = ObjectMapper().writeValueAsString(vendorData)
        val scanImageUrl: String? = vendorData.getFirst(JumioScanData.SCAN_IMAGE.s)
        val scanImageBacksideUrl:String? = vendorData.getFirst(JumioScanData.SCAN_IMAGE_FACE.s)
        val scanImageFaceUrl:String? = vendorData.getFirst(JumioScanData.SCAN_IMAGE_FACE.s)

        return IO {
            Either.monad<StoreError>().binding {
                var result: Pair<Blob, String>
                if (scanImageUrl != null) {
                    result = downloadFileAsBlob(scanImageUrl, apiToken, apiSecret).bind()
                    scanImage = result.first
                    scanImageType = result.second
                }
                if (scanImageBacksideUrl != null) {
                    result = downloadFileAsBlob(scanImageBacksideUrl, apiToken, apiSecret).bind()
                    scanImageBackside = result.first
                    scanImageBacksideType = result.second
                }
                if (scanImageFaceUrl != null) {
                    result = downloadFileAsBlob(scanImageFaceUrl, apiToken, apiSecret).bind()
                    scanImageFace = result.first
                    scanImageFaceType = result.second
                }
                VendorScanInformation(
                        scanId,
                        scanDetails,
                        scanImage,
                        scanImageType,
                        scanImageBackside,
                        scanImageBacksideType,
                        scanImageFace,
                        scanImageFaceType
                )
            }.fix()
        }.unsafeRunSync()
    }


    @JvmStatic
    fun main(args: Array<String>) {
        val fileURL = "https://jdbc.postgresql.org/download/postgresql-9.2-1002.jdbc4.jar"
        try {
            val ret = downloadFileAsBlob(fileURL, "", "")
            println(ret)
        } catch (ex: IOException) {
            ex.printStackTrace()
        }
    }
}